# 03 - Sprints Module

## Table of Contents
1. [Overview](#overview)
2. [Database Schema](#database-schema)
3. [Sprint Status Workflow](#sprint-status-workflow)
4. [Create Sprint (Manual)](#create-sprint-manual)
5. [Auto-Generate Sprints](#auto-generate-sprints)
6. [View Sprint List](#view-sprint-list)
7. [View Sprint Details](#view-sprint-details)
8. [Update Sprint](#update-sprint)
9. [Delete Sprint](#delete-sprint)
10. [Close Sprint](#close-sprint)
11. [Sprint Status Auto-Calculation](#sprint-status-auto-calculation)
12. [Daily Standup Slot Configuration](#daily-standup-slot-configuration)
13. [Validations & Business Rules](#validations--business-rules)
14. [Integration Points](#integration-points)
15. [API Reference](#api-reference)

---

## Overview

The **Sprints Module** manages time-boxed iterations within projects. Sprints are the fundamental units for organizing work, tracking daily standups, and monitoring progress through RAG (Red-Amber-Green) status indicators.

### Key Features
- **Manual Sprint Creation**: Create individual sprints with custom dates and goals
- **Auto-Generation**: Automatically generate sprints for the entire project timeline
- **Status Workflow**: UPCOMING â†’ ACTIVE â†’ COMPLETED â†’ CLOSED
- **Multi-Slot Standups**: Configure multiple daily standup slots per sprint
- **No Overlap Validation**: Ensures sprints never overlap within a project
- **Sprint Closure**: Formal closure process with card completion checks

### Module Location
```
Backend: F:\StandupSnap\backend\src\sprint\
Frontend: F:\StandupSnap\frontend\src\services\api\sprints.ts
```

---

## Database Schema

### Sprint Entity
**Location**: `F:\StandupSnap\backend\src\entities\sprint.entity.ts`

```typescript
@Entity('sprints')
export class Sprint {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => Project, (project) => project.sprints, { onDelete: 'CASCADE' })
  project: Project;

  @Column()
  name: string;

  @Column({ type: 'text', nullable: true })
  goal: string;

  @Column({ type: 'date' })
  startDate: Date;

  @Column({ type: 'date' })
  endDate: Date;

  @Column({ type: 'enum', enum: SprintStatus, default: SprintStatus.UPCOMING })
  status: SprintStatus;

  @Column({ type: 'enum', enum: SprintCreationType, default: SprintCreationType.MANUAL })
  creationType: SprintCreationType;

  @Column({ default: false })
  isClosed: boolean;

  @Column({ type: 'int', default: 1 })
  dailyStandupCount: number;

  @Column({ type: 'jsonb', nullable: true })
  slotTimes: Record<string, string>; // { "1": "09:00", "2": "15:00" }

  @OneToMany(() => StandupUpdate, (standupUpdate) => standupUpdate.sprint)
  standupUpdates: StandupUpdate[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

### Enums

#### SprintStatus
```typescript
export enum SprintStatus {
  UPCOMING = 'upcoming',    // Start date is in the future
  ACTIVE = 'active',        // Today is between start and end date
  COMPLETED = 'completed',  // End date has passed but not closed
  CLOSED = 'closed'         // Formally closed (isClosed = true)
}
```

#### SprintCreationType
```typescript
export enum SprintCreationType {
  MANUAL = 'manual',                    // Created by user
  AUTO_GENERATED = 'auto_generated'     // Auto-generated by system
}
```

### Database Table Structure

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique sprint identifier |
| project_id | UUID | FOREIGN KEY, NOT NULL | References projects table |
| name | VARCHAR | NOT NULL | Sprint name (e.g., "Sprint 1") |
| goal | TEXT | NULLABLE | Sprint goal/objective |
| startDate | DATE | NOT NULL | Sprint start date |
| endDate | DATE | NOT NULL | Sprint end date |
| status | ENUM | NOT NULL, DEFAULT 'upcoming' | Current sprint status |
| creationType | ENUM | NOT NULL, DEFAULT 'manual' | How sprint was created |
| isClosed | BOOLEAN | NOT NULL, DEFAULT false | Formal closure flag |
| dailyStandupCount | INTEGER | NOT NULL, DEFAULT 1 | Number of standup slots per day |
| slotTimes | JSONB | NULLABLE | Time mappings for slots |
| createdAt | TIMESTAMP | NOT NULL | Creation timestamp |
| updatedAt | TIMESTAMP | NOT NULL | Last update timestamp |

### Indexes
```sql
CREATE INDEX idx_sprints_project_id ON sprints(project_id);
CREATE INDEX idx_sprints_status ON sprints(status);
CREATE INDEX idx_sprints_dates ON sprints(startDate, endDate);
```

---

## Sprint Status Workflow

### Status Transition Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   UPCOMING   â”‚ (Start date in future)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ (Today >= Start date)
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    ACTIVE    â”‚ (Today between start & end)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ (Today > End date)
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMPLETED   â”‚ (End date passed)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ (SM/PO closes sprint)
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    CLOSED    â”‚ (Formally closed)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Status Calculation Logic
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 571-592)

```typescript
private calculateSprintStatus(
  startDate: Date,
  endDate: Date,
  isClosed: boolean = false
): SprintStatus {
  if (isClosed) {
    return SprintStatus.CLOSED;
  }

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const start = new Date(startDate);
  start.setHours(0, 0, 0, 0);

  const end = new Date(endDate);
  end.setHours(0, 0, 0, 0);

  if (today < start) {
    return SprintStatus.UPCOMING;
  } else if (today >= start && today <= end) {
    return SprintStatus.ACTIVE;
  } else {
    return SprintStatus.COMPLETED;
  }
}
```

### Auto-Update Behavior
- Status is **automatically recalculated** whenever a sprint is fetched
- Updates happen at:
  - `findOne()` - Single sprint retrieval
  - `findAll()` - Sprint list retrieval
  - `update()` - Sprint modification
- No manual status changes allowed (system-calculated only)

---

## Create Sprint (Manual)

### Use Case: M6-UC01
**Trigger**: User clicks "Create Sprint" button
**Permission Required**: `CREATE_SPRINT`
**Service Method**: `sprint.service.ts` â†’ `create()`

### Screen Flow

#### Step 1: Open Sprint Creation Form
```
Project Details Page
â””â”€ Sprints Tab
   â””â”€ [+ Create Sprint] Button
      â””â”€ Opens Modal/Form
```

#### Form Fields
| Field | Type | Required | Default | Validation |
|-------|------|----------|---------|------------|
| Sprint Name | Text | Yes | - | Unique within project |
| Sprint Goal | Textarea | No | - | Max 1000 chars |
| Start Date | Date Picker | Yes | - | >= Project start date |
| End Date | Date Picker | Yes | - | <= Project end date, >= Start date |
| Daily Standup Count | Number | No | 1 | Min: 1, Max: 5 |
| Slot Times | Time Pickers | Conditional | - | Required if count > 1 |

#### Slot Time Configuration
When `dailyStandupCount > 1`:
```
Slot 1 Time: [09:00] (Default)
Slot 2 Time: [15:00]
Slot 3 Time: [__:__]
```

### User Journey

```
1. User clicks "Create Sprint"
   â†“
2. Form opens with empty fields
   â†“
3. User enters:
   - Sprint Name: "Sprint 1"
   - Goal: "Complete user authentication module"
   - Start Date: 2025-01-06
   - End Date: 2025-01-19 (2 weeks)
   - Daily Standup Count: 2
   - Slot 1 Time: 09:00
   - Slot 2 Time: 15:00
   â†“
4. User clicks "Save"
   â†“
5. System validates (see validations section)
   â†“
6. Sprint created with status = UPCOMING (if start date is future)
   â†“
7. Success message displayed
   â†“
8. Sprint appears in sprint list
```

### API Flow

#### API Endpoint
```
POST /api/sprints
Authorization: Bearer <JWT_TOKEN>
Content-Type: application/json
```

#### Request Payload
```json
{
  "projectId": "123e4567-e89b-12d3-a456-426614174000",
  "name": "Sprint 1",
  "goal": "Complete user authentication module",
  "startDate": "2025-01-06",
  "endDate": "2025-01-19",
  "dailyStandupCount": 2,
  "slotTimes": {
    "1": "09:00",
    "2": "15:00"
  }
}
```

#### Backend Processing
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 45-91)

```typescript
async create(createSprintDto: CreateSprintDto): Promise<Sprint> {
  const { projectId, name, goal, startDate, endDate, dailyStandupCount, slotTimes } = createSprintDto;

  // 1. Find the project
  const project = await this.projectRepository.findOne({ where: { id: projectId } });
  if (!project) {
    throw new NotFoundException(`Project with ID ${projectId} not found`);
  }

  // 2. Validate project is not archived
  if (project.isArchived) {
    throw new BadRequestException('Cannot create sprints in archived project');
  }

  // 3. Validate project has valid start & end dates
  if (!project.startDate || !project.endDate) {
    throw new BadRequestException('Project must have valid start and end dates');
  }

  const start = new Date(startDate);
  const end = new Date(endDate);

  // 4. Validate sprint dates
  await this.validateSprintDates(start, end, project, null);

  // 5. Validate unique sprint name within project
  await this.validateUniqueSprintName(name, projectId, null);

  // 6. Create sprint
  const sprint = this.sprintRepository.create({
    name,
    goal,
    startDate: start,
    endDate: end,
    status: this.calculateSprintStatus(start, end),
    creationType: SprintCreationType.MANUAL,
    isClosed: false,
    dailyStandupCount: dailyStandupCount || 1,
    slotTimes: slotTimes || null,
    project,
  });

  return this.sprintRepository.save(sprint);
}
```

#### Database Query
```sql
-- Insert sprint
INSERT INTO sprints (
  id,
  project_id,
  name,
  goal,
  "startDate",
  "endDate",
  status,
  "creationType",
  "isClosed",
  "dailyStandupCount",
  "slotTimes",
  "createdAt",
  "updatedAt"
) VALUES (
  gen_random_uuid(),
  '123e4567-e89b-12d3-a456-426614174000',
  'Sprint 1',
  'Complete user authentication module',
  '2025-01-06',
  '2025-01-19',
  'upcoming',
  'manual',
  false,
  2,
  '{"1":"09:00","2":"15:00"}',
  NOW(),
  NOW()
) RETURNING *;
```

#### Response (200 OK)
```json
{
  "id": "789e0123-e89b-12d3-a456-426614174000",
  "project": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "name": "E-Commerce Platform"
  },
  "name": "Sprint 1",
  "goal": "Complete user authentication module",
  "startDate": "2025-01-06",
  "endDate": "2025-01-19",
  "status": "upcoming",
  "creationType": "manual",
  "isClosed": false,
  "dailyStandupCount": 2,
  "slotTimes": {
    "1": "09:00",
    "2": "15:00"
  },
  "createdAt": "2025-01-02T10:30:00.000Z",
  "updatedAt": "2025-01-02T10:30:00.000Z"
}
```

### Error Responses

#### Project Not Found (404)
```json
{
  "statusCode": 404,
  "message": "Project with ID 123e4567-e89b-12d3-a456-426614174000 not found",
  "error": "Not Found"
}
```

#### Archived Project (400)
```json
{
  "statusCode": 400,
  "message": "Cannot create sprints in archived project",
  "error": "Bad Request"
}
```

#### Date Out of Range (400)
```json
{
  "statusCode": 400,
  "message": "Sprint must lie within project timeline",
  "error": "Bad Request"
}
```

#### Sprint Overlap (400)
```json
{
  "statusCode": 400,
  "message": "Sprint overlaps with existing sprint",
  "error": "Bad Request"
}
```

#### Duplicate Name (400)
```json
{
  "statusCode": 400,
  "message": "Sprint name must be unique within project",
  "error": "Bad Request"
}
```

---

## Auto-Generate Sprints

### Use Case: M6-UC01 (Auto-Generation Variant)
**Trigger**: User clicks "Auto-Generate Sprints"
**Permission Required**: `CREATE_SPRINT`
**Service Method**: `sprint.service.ts` â†’ `generateSprints()`

### Screen Flow

#### Step 1: Open Auto-Generation Form
```
Project Details Page
â””â”€ Sprints Tab
   â””â”€ [Auto-Generate Sprints] Button
      â””â”€ Opens Configuration Modal
```

#### Configuration Form
| Field | Type | Required | Default | Validation |
|-------|------|----------|---------|------------|
| Sprint Duration | Number (weeks) | Yes | 2 | Min: 1, Max: 8 |
| Name Prefix | Text | No | "Sprint" | Max 50 chars |
| Daily Standup Count | Number | No | 1 | Min: 1, Max: 5 |
| Slot Times | Time Pickers | Conditional | - | Required if count > 1 |

#### Step 2: Preview Generated Sprints
```
Preview Modal
â”œâ”€ Sprint 1: Jan 6 - Jan 19 (14 days)
â”œâ”€ Sprint 2: Jan 20 - Feb 2 (14 days)
â”œâ”€ Sprint 3: Feb 3 - Feb 16 (14 days)
â”œâ”€ Sprint 4: Feb 17 - Mar 2 (14 days)
â””â”€ [Cancel] [Generate All]
```

### User Journey

```
1. User clicks "Auto-Generate Sprints"
   â†“
2. Configuration form opens
   â†“
3. User enters:
   - Sprint Duration: 2 weeks
   - Name Prefix: "Sprint"
   - Daily Standup Count: 1
   â†“
4. User clicks "Preview"
   â†“
5. System calculates sprint breakdown:
   - Project: Jan 6 - Mar 31 (84 days)
   - Sprint duration: 14 days
   - Number of sprints: 6
   â†“
6. Preview shows 6 sprints with dates
   â†“
7. User reviews and clicks "Generate All"
   â†“
8. System validates no overlaps with existing sprints
   â†“
9. All 6 sprints created atomically
   â†“
10. Success message: "6 sprints generated successfully"
    â†“
11. Sprint list refreshes showing new sprints
```

### API Flow (Preview)

#### API Endpoint
```
POST /api/sprints/preview
Authorization: Bearer <JWT_TOKEN>
Content-Type: application/json
```

#### Request Payload
```json
{
  "projectId": "123e4567-e89b-12d3-a456-426614174000",
  "sprintDurationWeeks": 2,
  "namePrefix": "Sprint",
  "dailyStandupCount": 1
}
```

#### Backend Processing (Preview)
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 97-152)

```typescript
async previewSprints(previewDto: PreviewSprintsDto): Promise<SprintPreview[]> {
  const { projectId, sprintDurationWeeks, namePrefix, dailyStandupCount } = previewDto;

  // Find the project
  const project = await this.projectRepository.findOne({ where: { id: projectId } });
  if (!project) {
    throw new NotFoundException(`Project with ID ${projectId} not found`);
  }

  // Validate project has end date
  if (!project.endDate) {
    throw new BadRequestException('Project must have an end date for auto-generation');
  }

  const previews: SprintPreview[] = [];
  let sprintNumber = 1;
  let currentStartDate = new Date(project.startDate);
  const projectEndDate = new Date(project.endDate);
  const prefix = namePrefix || 'Sprint';

  while (currentStartDate < projectEndDate) {
    // Calculate end date for this sprint
    const sprintEndDate = new Date(currentStartDate);
    sprintEndDate.setDate(sprintEndDate.getDate() + sprintDurationWeeks * 7 - 1);

    // If sprint end date exceeds project end date, adjust it
    const finalEndDate = sprintEndDate > projectEndDate ? projectEndDate : sprintEndDate;

    // Calculate duration in days
    const durationDays = Math.ceil(
      (finalEndDate.getTime() - currentStartDate.getTime()) / (1000 * 60 * 60 * 24)
    ) + 1;

    previews.push({
      name: `${prefix} ${sprintNumber}`,
      startDate: new Date(currentStartDate),
      endDate: finalEndDate,
      durationDays,
      dailyStandupCount: dailyStandupCount || 1,
    });

    // Move to next sprint start date
    currentStartDate = new Date(finalEndDate);
    currentStartDate.setDate(currentStartDate.getDate() + 1);
    sprintNumber++;

    // Safety check
    if (sprintNumber > 100) {
      throw new BadRequestException('Cannot generate more than 100 sprints');
    }
  }

  return previews;
}
```

#### Response (200 OK)
```json
[
  {
    "name": "Sprint 1",
    "startDate": "2025-01-06",
    "endDate": "2025-01-19",
    "durationDays": 14,
    "dailyStandupCount": 1
  },
  {
    "name": "Sprint 2",
    "startDate": "2025-01-20",
    "endDate": "2025-02-02",
    "durationDays": 14,
    "dailyStandupCount": 1
  },
  {
    "name": "Sprint 3",
    "startDate": "2025-02-03",
    "endDate": "2025-02-16",
    "durationDays": 14,
    "dailyStandupCount": 1
  },
  {
    "name": "Sprint 4",
    "startDate": "2025-02-17",
    "endDate": "2025-03-02",
    "durationDays": 14,
    "dailyStandupCount": 1
  },
  {
    "name": "Sprint 5",
    "startDate": "2025-03-03",
    "endDate": "2025-03-16",
    "durationDays": 14,
    "dailyStandupCount": 1
  },
  {
    "name": "Sprint 6",
    "startDate": "2025-03-17",
    "endDate": "2025-03-30",
    "durationDays": 14,
    "dailyStandupCount": 1
  }
]
```

### API Flow (Generate)

#### API Endpoint
```
POST /api/sprints/generate
Authorization: Bearer <JWT_TOKEN>
Content-Type: application/json
```

#### Request Payload
```json
{
  "projectId": "123e4567-e89b-12d3-a456-426614174000",
  "sprintDurationWeeks": 2,
  "namePrefix": "Sprint",
  "dailyStandupCount": 1,
  "slotTimes": null
}
```

#### Backend Processing (Generate)
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 161-252)

```typescript
async generateSprints(generateDto: GenerateSprintsDto): Promise<Sprint[]> {
  const { projectId, sprintDurationWeeks, namePrefix, dailyStandupCount, slotTimes } = generateDto;

  // Find the project
  const project = await this.projectRepository.findOne({ where: { id: projectId } });
  if (!project) {
    throw new NotFoundException(`Project with ID ${projectId} not found`);
  }

  // Validate project is not archived
  if (project.isArchived) {
    throw new BadRequestException('Cannot generate sprints in archived project');
  }

  // Validate project has end date
  if (!project.endDate) {
    throw new BadRequestException('Auto-generation requires project end date');
  }

  // Get existing sprints to check for overlaps
  const existingSprints = await this.sprintRepository.find({
    where: { project: { id: projectId } },
    order: { startDate: 'ASC' },
  });

  const sprints: Sprint[] = [];
  let sprintNumber = 1;
  let currentStartDate = new Date(project.startDate);
  const projectEndDate = new Date(project.endDate);
  const prefix = namePrefix || 'Sprint';

  while (currentStartDate < projectEndDate) {
    // Calculate end date for this sprint
    const sprintEndDate = new Date(currentStartDate);
    sprintEndDate.setDate(sprintEndDate.getDate() + sprintDurationWeeks * 7 - 1);

    // Adjust if exceeds project end
    const finalEndDate = sprintEndDate > projectEndDate ? projectEndDate : sprintEndDate;

    // Check for overlap with existing sprints
    const hasOverlap = this.checkSprintOverlap(
      currentStartDate,
      finalEndDate,
      existingSprints,
      null
    );

    if (hasOverlap) {
      throw new BadRequestException(
        'Auto-generated sprint would overlap with existing sprint. Resolve conflicts before auto-generating.'
      );
    }

    // Create sprint
    const sprint = this.sprintRepository.create({
      name: `${prefix} ${sprintNumber}`,
      goal: `Auto-generated sprint ${sprintNumber}`,
      startDate: currentStartDate,
      endDate: finalEndDate,
      status: this.calculateSprintStatus(currentStartDate, finalEndDate),
      creationType: SprintCreationType.AUTO_GENERATED,
      isClosed: false,
      dailyStandupCount: dailyStandupCount || 1,
      slotTimes: slotTimes || null,
      project,
    });

    sprints.push(sprint);

    // Move to next sprint
    currentStartDate = new Date(finalEndDate);
    currentStartDate.setDate(currentStartDate.getDate() + 1);
    sprintNumber++;

    // Safety check
    if (sprintNumber > 100) {
      throw new BadRequestException('Cannot generate more than 100 sprints');
    }
  }

  // Validate at least one sprint
  if (sprints.length === 0) {
    throw new BadRequestException('Cannot generate sprints with selected duration');
  }

  // Save all sprints in one batch
  return this.sprintRepository.save(sprints);
}
```

#### Database Queries
```sql
-- Batch insert all sprints
INSERT INTO sprints (
  id, project_id, name, goal, "startDate", "endDate",
  status, "creationType", "isClosed", "dailyStandupCount",
  "slotTimes", "createdAt", "updatedAt"
)
VALUES
  (gen_random_uuid(), '...', 'Sprint 1', 'Auto-generated sprint 1', '2025-01-06', '2025-01-19', 'upcoming', 'auto_generated', false, 1, NULL, NOW(), NOW()),
  (gen_random_uuid(), '...', 'Sprint 2', 'Auto-generated sprint 2', '2025-01-20', '2025-02-02', 'upcoming', 'auto_generated', false, 1, NULL, NOW(), NOW()),
  (gen_random_uuid(), '...', 'Sprint 3', 'Auto-generated sprint 3', '2025-02-03', '2025-02-16', 'upcoming', 'auto_generated', false, 1, NULL, NOW(), NOW()),
  (gen_random_uuid(), '...', 'Sprint 4', 'Auto-generated sprint 4', '2025-02-17', '2025-03-02', 'upcoming', 'auto_generated', false, 1, NULL, NOW(), NOW()),
  (gen_random_uuid(), '...', 'Sprint 5', 'Auto-generated sprint 5', '2025-03-03', '2025-03-16', 'upcoming', 'auto_generated', false, 1, NULL, NOW(), NOW()),
  (gen_random_uuid(), '...', 'Sprint 6', 'Auto-generated sprint 6', '2025-03-17', '2025-03-30', 'upcoming', 'auto_generated', false, 1, NULL, NOW(), NOW())
RETURNING *;
```

#### Response (201 Created)
Returns array of created sprints (same structure as manual creation response).

### Overlap Detection Algorithm
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 511-542)

```typescript
private checkSprintOverlap(
  startDate: Date,
  endDate: Date,
  existingSprints: Sprint[],
  excludeSprintId: string | null
): boolean {
  const normalizeDate = (date: Date) => {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    return d;
  };

  const newStart = normalizeDate(startDate).getTime();
  const newEnd = normalizeDate(endDate).getTime();

  for (const sprint of existingSprints) {
    // Skip the sprint being edited
    if (excludeSprintId && sprint.id === excludeSprintId) {
      continue;
    }

    const existingStart = normalizeDate(sprint.startDate).getTime();
    const existingEnd = normalizeDate(sprint.endDate).getTime();

    // Check if there's any overlap
    // Overlap condition: newStart <= existingEnd AND newEnd >= existingStart
    if (newStart <= existingEnd && newEnd >= existingStart) {
      return true;
    }
  }

  return false;
}
```

---

## View Sprint List

### Use Case: M6-UC02 & M6-UC07
**Trigger**: User navigates to Sprints tab
**Permission Required**: `VIEW_SPRINT`
**Service Method**: `sprint.service.ts` â†’ `findAll()`

### Screen Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Project: E-Commerce Platform                       Sprints   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚ [+ Create Sprint]  [Auto-Generate]  [Filter â–¼]  [Search ğŸ”] â”‚
â”‚                                                               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Filters:                                                 â”‚ â”‚
â”‚ â”‚ Status: [All â–¼] | Search: [________________]            â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚  Sprint Name    â”‚  Dates         â”‚  Status    â”‚ Actionsâ”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚  Sprint 1       â”‚  Jan 6-Jan 19  â”‚  ğŸŸ¢ ACTIVE â”‚ [Â·Â·Â·]  â”‚ â”‚
â”‚ â”‚  Sprint 2       â”‚  Jan 20-Feb 2  â”‚  âšª UPCOMINGâ”‚ [Â·Â·Â·]  â”‚ â”‚
â”‚ â”‚  Sprint 3       â”‚  Feb 3-Feb 16  â”‚  âšª UPCOMINGâ”‚ [Â·Â·Â·]  â”‚ â”‚
â”‚ â”‚  Sprint 4       â”‚  Feb 17-Mar 2  â”‚  âšª UPCOMINGâ”‚ [Â·Â·Â·]  â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### API Flow

#### API Endpoint
```
GET /api/sprints?projectId={projectId}&status={status}&search={search}
Authorization: Bearer <JWT_TOKEN>
```

#### Query Parameters
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| projectId | UUID | Yes | Filter by project |
| status | SprintStatus | No | Filter by status (upcoming/active/completed/closed) |
| search | String | No | Search sprint names (case-insensitive) |

#### Backend Processing
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 257-288)

```typescript
async findAll(
  projectId?: string,
  status?: SprintStatus,
  search?: string
): Promise<Sprint[]> {
  const queryBuilder = this.sprintRepository
    .createQueryBuilder('sprint')
    .leftJoinAndSelect('sprint.project', 'project')
    .orderBy('sprint.startDate', 'ASC');

  // Filter by project if provided
  if (projectId) {
    queryBuilder.andWhere('sprint.project.id = :projectId', { projectId });
  }

  // Filter by status
  if (status) {
    queryBuilder.andWhere('sprint.status = :status', { status });
  }

  // Search by name
  if (search) {
    queryBuilder.andWhere('LOWER(sprint.name) LIKE LOWER(:search)', {
      search: `%${search}%`,
    });
  }

  const sprints = await queryBuilder.getMany();

  // Update sprint statuses based on current date
  return this.updateSprintStatuses(sprints);
}
```

#### Database Query
```sql
SELECT
  sprint.*,
  project.id AS "project_id",
  project.name AS "project_name"
FROM sprints sprint
LEFT JOIN projects project ON sprint.project_id = project.id
WHERE sprint.project_id = '123e4567-e89b-12d3-a456-426614174000'
  AND (sprint.status = 'active' OR :status IS NULL)
  AND (LOWER(sprint.name) LIKE LOWER('%sprint%') OR :search IS NULL)
ORDER BY sprint."startDate" ASC;
```

#### Response (200 OK)
```json
[
  {
    "id": "789e0123-e89b-12d3-a456-426614174000",
    "project": {
      "id": "123e4567-e89b-12d3-a456-426614174000",
      "name": "E-Commerce Platform"
    },
    "name": "Sprint 1",
    "goal": "Complete user authentication module",
    "startDate": "2025-01-06",
    "endDate": "2025-01-19",
    "status": "active",
    "creationType": "manual",
    "isClosed": false,
    "dailyStandupCount": 2,
    "slotTimes": {
      "1": "09:00",
      "2": "15:00"
    },
    "createdAt": "2025-01-02T10:30:00.000Z",
    "updatedAt": "2025-01-02T10:30:00.000Z"
  },
  {
    "id": "890e1234-e89b-12d3-a456-426614174001",
    "project": {
      "id": "123e4567-e89b-12d3-a456-426614174000",
      "name": "E-Commerce Platform"
    },
    "name": "Sprint 2",
    "goal": "Implement product catalog",
    "startDate": "2025-01-20",
    "endDate": "2025-02-02",
    "status": "upcoming",
    "creationType": "manual",
    "isClosed": false,
    "dailyStandupCount": 1,
    "slotTimes": null,
    "createdAt": "2025-01-02T10:35:00.000Z",
    "updatedAt": "2025-01-02T10:35:00.000Z"
  }
]
```

---

## View Sprint Details

### Use Case: M6-UC02
**Trigger**: User clicks on a sprint from the list
**Permission Required**: `VIEW_SPRINT`
**Service Method**: `sprint.service.ts` â†’ `findOne()`

### Screen Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â† Back to Sprints                Sprint 1 Details            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚ Sprint Name: Sprint 1                     Status: ğŸŸ¢ ACTIVE  â”‚
â”‚ Goal: Complete user authentication module                    â”‚
â”‚                                                               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Sprint Information                                       â”‚ â”‚
â”‚ â”‚ â€¢ Start Date: January 6, 2025                            â”‚ â”‚
â”‚ â”‚ â€¢ End Date: January 19, 2025                             â”‚ â”‚
â”‚ â”‚ â€¢ Duration: 14 days                                      â”‚ â”‚
â”‚ â”‚ â€¢ Creation Type: Manual                                  â”‚ â”‚
â”‚ â”‚ â€¢ Status: Active (Day 8 of 14)                           â”‚ â”‚
â”‚ â”‚ â€¢ Daily Standup Slots: 2                                 â”‚ â”‚
â”‚ â”‚   - Slot 1: 09:00 AM                                     â”‚ â”‚
â”‚ â”‚   - Slot 2: 03:00 PM                                     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Sprint Statistics                                        â”‚ â”‚
â”‚ â”‚ â€¢ Total Cards: 12                                        â”‚ â”‚
â”‚ â”‚ â€¢ Completed: 5                                           â”‚ â”‚
â”‚ â”‚ â€¢ In Progress: 4                                         â”‚ â”‚
â”‚ â”‚ â€¢ Not Started: 3                                         â”‚ â”‚
â”‚ â”‚ â€¢ Sprint RAG: ğŸŸ¡ AMBER                                   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â”‚ [Edit Sprint]  [Close Sprint]  [Delete Sprint]              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### API Flow

#### API Endpoint
```
GET /api/sprints/:id
Authorization: Bearer <JWT_TOKEN>
```

#### Backend Processing
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 293-308)

```typescript
async findOne(id: string): Promise<Sprint> {
  const sprint = await this.sprintRepository.findOne({
    where: { id },
    relations: ['project'],
  });

  if (!sprint) {
    throw new NotFoundException(`Sprint with ID ${id} not found`);
  }

  // Update status based on current date
  sprint.status = this.calculateSprintStatus(
    sprint.startDate,
    sprint.endDate,
    sprint.isClosed
  );
  await this.sprintRepository.save(sprint);

  return sprint;
}
```

#### Database Query
```sql
SELECT
  sprint.*,
  project.id AS "project_id",
  project.name AS "project_name",
  project."startDate" AS "project_startDate",
  project."endDate" AS "project_endDate"
FROM sprints sprint
LEFT JOIN projects project ON sprint.project_id = project.id
WHERE sprint.id = '789e0123-e89b-12d3-a456-426614174000';

-- Update status if changed
UPDATE sprints
SET status = 'active', "updatedAt" = NOW()
WHERE id = '789e0123-e89b-12d3-a456-426614174000';
```

#### Response (200 OK)
```json
{
  "id": "789e0123-e89b-12d3-a456-426614174000",
  "project": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "name": "E-Commerce Platform",
    "startDate": "2025-01-06",
    "endDate": "2025-03-31"
  },
  "name": "Sprint 1",
  "goal": "Complete user authentication module",
  "startDate": "2025-01-06",
  "endDate": "2025-01-19",
  "status": "active",
  "creationType": "manual",
  "isClosed": false,
  "dailyStandupCount": 2,
  "slotTimes": {
    "1": "09:00",
    "2": "15:00"
  },
  "createdAt": "2025-01-02T10:30:00.000Z",
  "updatedAt": "2025-01-13T14:22:00.000Z"
}
```

---

## Update Sprint

### Use Case: M6-UC03
**Trigger**: User clicks "Edit" on a sprint
**Permission Required**: `EDIT_SPRINT`
**Service Method**: `sprint.service.ts` â†’ `update()`

### Editable Fields
- Sprint Name
- Sprint Goal
- Start Date
- End Date
- Daily Standup Count
- Slot Times

### Business Rules for Updates
1. **Cannot edit closed sprints**: If `isClosed = true`, editing is blocked
2. **Cannot edit in archived projects**: Project must be active
3. **Date changes must not cause overlaps**: New dates validated against all other sprints
4. **Name must remain unique**: Name uniqueness checked within project
5. **Status recalculated**: Status automatically updated based on new dates

### API Flow

#### API Endpoint
```
PATCH /api/sprints/:id
Authorization: Bearer <JWT_TOKEN>
Content-Type: application/json
```

#### Request Payload (Partial Update)
```json
{
  "name": "Sprint 1 - Authentication",
  "goal": "Complete user authentication and authorization module",
  "endDate": "2025-01-21",
  "dailyStandupCount": 3,
  "slotTimes": {
    "1": "09:00",
    "2": "12:00",
    "3": "15:00"
  }
}
```

#### Backend Processing
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 319-368)

```typescript
async update(id: string, updateSprintDto: UpdateSprintDto): Promise<Sprint> {
  const sprint = await this.findOne(id);

  // Validate project is not archived
  if (sprint.project.isArchived) {
    throw new BadRequestException('Cannot update sprints in archived project');
  }

  // Validate sprint is not closed
  if (sprint.isClosed) {
    throw new BadRequestException('Closed sprint cannot be edited');
  }

  const { name, goal, startDate, endDate, dailyStandupCount, slotTimes } = updateSprintDto;

  // If dates are being updated, validate them
  if (startDate || endDate) {
    const newStartDate = startDate ? new Date(startDate) : sprint.startDate;
    const newEndDate = endDate ? new Date(endDate) : sprint.endDate;

    await this.validateSprintDates(newStartDate, newEndDate, sprint.project, id);

    sprint.startDate = newStartDate;
    sprint.endDate = newEndDate;
    sprint.status = this.calculateSprintStatus(newStartDate, newEndDate, sprint.isClosed);
  }

  // If name is being updated, validate uniqueness
  if (name && name !== sprint.name) {
    await this.validateUniqueSprintName(name, sprint.project.id, id);
    sprint.name = name;
  }

  // Update goal if provided
  if (goal !== undefined) {
    sprint.goal = goal;
  }

  // Update dailyStandupCount if provided
  if (dailyStandupCount !== undefined) {
    sprint.dailyStandupCount = dailyStandupCount;
  }

  // Update slotTimes if provided
  if (slotTimes !== undefined) {
    sprint.slotTimes = slotTimes;
  }

  return this.sprintRepository.save(sprint);
}
```

#### Database Query
```sql
UPDATE sprints
SET
  name = 'Sprint 1 - Authentication',
  goal = 'Complete user authentication and authorization module',
  "endDate" = '2025-01-21',
  "dailyStandupCount" = 3,
  "slotTimes" = '{"1":"09:00","2":"12:00","3":"15:00"}',
  status = 'active',
  "updatedAt" = NOW()
WHERE id = '789e0123-e89b-12d3-a456-426614174000'
RETURNING *;
```

#### Response (200 OK)
Returns updated sprint object (same structure as findOne response).

### Error Responses

#### Closed Sprint (400)
```json
{
  "statusCode": 400,
  "message": "Closed sprint cannot be edited",
  "error": "Bad Request"
}
```

#### Overlap After Update (400)
```json
{
  "statusCode": 400,
  "message": "Sprint overlaps with existing sprint",
  "error": "Bad Request"
}
```

---

## Delete Sprint

### Use Case: M6-UC04
**Trigger**: User clicks "Delete" on a sprint
**Permission Required**: `DELETE_SPRINT`
**Service Method**: `sprint.service.ts` â†’ `remove()`

### Business Rules for Deletion
1. **Cannot delete if has snap history**: Sprint with standupUpdates cannot be deleted
2. **Cannot delete if has cards**: Sprint containing cards cannot be deleted (checked in CardService)
3. **Cannot delete active sprint**: Sprint with status=ACTIVE cannot be deleted
4. **Cannot delete in archived project**: Project must be active

### Confirmation Dialog
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âš ï¸  Delete Sprint?                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                              â”‚
â”‚  Are you sure you want to delete            â”‚
â”‚  "Sprint 3"?                                 â”‚
â”‚                                              â”‚
â”‚  This action cannot be undone.              â”‚
â”‚                                              â”‚
â”‚  Sprint details:                            â”‚
â”‚  â€¢ Date: Feb 3 - Feb 16                     â”‚
â”‚  â€¢ Status: UPCOMING                         â”‚
â”‚  â€¢ Cards: 0                                 â”‚
â”‚  â€¢ Snaps: 0                                 â”‚
â”‚                                              â”‚
â”‚         [Cancel]  [Delete Sprint]           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### API Flow

#### API Endpoint
```
DELETE /api/sprints/:id
Authorization: Bearer <JWT_TOKEN>
```

#### Backend Processing
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 378-408)

```typescript
async remove(id: string): Promise<void> {
  const sprint = await this.sprintRepository.findOne({
    where: { id },
    relations: ['project', 'standupUpdates'],
  });

  if (!sprint) {
    throw new NotFoundException(`Sprint with ID ${id} not found`);
  }

  // Validate project is not archived
  if (sprint.project.isArchived) {
    throw new BadRequestException('Cannot delete sprints in archived project');
  }

  // Validate sprint has no snap history
  if (sprint.standupUpdates && sprint.standupUpdates.length > 0) {
    throw new BadRequestException('Sprint contains snap history. Sprint cannot be deleted.');
  }

  // Validate sprint is not currently active
  const status = this.calculateSprintStatus(sprint.startDate, sprint.endDate, sprint.isClosed);
  if (status === SprintStatus.ACTIVE) {
    throw new BadRequestException('Active sprint cannot be deleted');
  }

  // TODO: Add validation for cards when Card module is implemented
  // For now, we'll assume this check will be added later

  await this.sprintRepository.remove(sprint);
}
```

#### Database Query
```sql
-- Check for snap history
SELECT COUNT(*) FROM standup_updates
WHERE sprint_id = '789e0123-e89b-12d3-a456-426614174000';

-- Check for cards (added when Card module integrated)
SELECT COUNT(*) FROM cards
WHERE sprint_id = '789e0123-e89b-12d3-a456-426614174000';

-- If validations pass, delete sprint
DELETE FROM sprints
WHERE id = '789e0123-e89b-12d3-a456-426614174000';
```

#### Response (204 No Content)
Empty response body.

### Error Responses

#### Has Snap History (400)
```json
{
  "statusCode": 400,
  "message": "Sprint contains snap history. Sprint cannot be deleted.",
  "error": "Bad Request"
}
```

#### Active Sprint (400)
```json
{
  "statusCode": 400,
  "message": "Active sprint cannot be deleted",
  "error": "Bad Request"
}
```

---

## Close Sprint

### Use Case: M6-UC06
**Trigger**: User clicks "Close Sprint" button
**Permission Required**: `EDIT_SPRINT`
**Service Method**: `sprint.service.ts` â†’ `closeSprint()`

### Business Rules for Closure
1. **Sprint must be Active or Completed**: Cannot close UPCOMING sprints
2. **All cards must be completed**: No IN_PROGRESS or NOT_STARTED cards allowed
3. **Only SM/PO can close**: Permission check enforced
4. **Project must not be archived**: Validation on project status
5. **Cannot close already closed sprint**: Check `isClosed` flag

### Sprint Closure Flow

```
1. User clicks "Close Sprint"
   â†“
2. System validates:
   - Sprint is Active/Completed
   - All cards are in COMPLETED status
   - User has permission
   - Project is not archived
   â†“
3. System marks all COMPLETED cards as CLOSED
   â†“
4. System sets sprint.isClosed = true
   â†“
5. System sets sprint.status = CLOSED
   â†“
6. Sprint closure complete
   â†“
7. Success message displayed
```

### Confirmation Dialog
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ”’ Close Sprint?                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                              â”‚
â”‚  Close "Sprint 1"?                          â”‚
â”‚                                              â”‚
â”‚  This will:                                 â”‚
â”‚  â€¢ Mark sprint as CLOSED                    â”‚
â”‚  â€¢ Mark all completed cards as CLOSED       â”‚
â”‚  â€¢ Prevent further snaps                    â”‚
â”‚  â€¢ Lock all data in this sprint            â”‚
â”‚                                              â”‚
â”‚  Sprint summary:                            â”‚
â”‚  â€¢ Total Cards: 12                          â”‚
â”‚  â€¢ Completed: 12                            â”‚
â”‚  â€¢ In Progress: 0                           â”‚
â”‚  â€¢ Not Started: 0                           â”‚
â”‚                                              â”‚
â”‚  This action cannot be undone.              â”‚
â”‚                                              â”‚
â”‚         [Cancel]  [Close Sprint]            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### API Flow

#### API Endpoint
```
POST /api/sprints/:id/close
Authorization: Bearer <JWT_TOKEN>
```

#### Backend Processing
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 418-450)

```typescript
async closeSprint(id: string): Promise<Sprint> {
  const sprint = await this.findOne(id);

  // Validate project is not archived
  if (sprint.project.isArchived) {
    throw new BadRequestException('Cannot close sprints in archived project');
  }

  // Validate sprint is not already closed
  if (sprint.isClosed) {
    throw new BadRequestException('Sprint is already closed');
  }

  // Validate sprint is Active or Completed
  const status = this.calculateSprintStatus(sprint.startDate, sprint.endDate, sprint.isClosed);
  if (status === SprintStatus.UPCOMING) {
    throw new BadRequestException('Upcoming sprints cannot be closed');
  }

  // M7-UC06: Validate all cards are completed
  const allCardsCompleted = await this.cardService.areAllCardsCompleted(id);
  if (!allCardsCompleted) {
    throw new BadRequestException(
      'Sprint contains active cards. Complete or move all active cards before closing the sprint.'
    );
  }

  sprint.isClosed = true;
  sprint.status = SprintStatus.CLOSED;

  // M7-UC06: Mark all completed cards as closed
  await this.cardService.closeAllCardsInSprint(id);

  return this.sprintRepository.save(sprint);
}
```

#### Card Validation Query
**Location**: `F:\StandupSnap\backend\src\card\card.service.ts` (lines 368-376)

```typescript
async areAllCardsCompleted(sprintId: string): Promise<boolean> {
  const cards = await this.getCardsBySprintId(sprintId);

  if (cards.length === 0) {
    return true; // Empty sprint can be closed
  }

  return cards.every(card => card.status === CardStatus.COMPLETED);
}
```

```sql
-- Check if all cards are completed
SELECT
  id,
  title,
  status
FROM cards
WHERE sprint_id = '789e0123-e89b-12d3-a456-426614174000'
  AND status != 'completed';
-- If query returns any rows, validation fails
```

#### Card Closure Query
**Location**: `F:\StandupSnap\backend\src\card\card.service.ts` (lines 381-390)

```typescript
async closeAllCardsInSprint(sprintId: string): Promise<void> {
  const cards = await this.getCardsBySprintId(sprintId);

  for (const card of cards) {
    if (card.status === CardStatus.COMPLETED) {
      card.status = CardStatus.CLOSED;
      await this.cardRepository.save(card);
    }
  }
}
```

```sql
-- Mark all completed cards as closed
UPDATE cards
SET status = 'closed', "updatedAt" = NOW()
WHERE sprint_id = '789e0123-e89b-12d3-a456-426614174000'
  AND status = 'completed';
```

#### Sprint Update Query
```sql
UPDATE sprints
SET
  "isClosed" = true,
  status = 'closed',
  "updatedAt" = NOW()
WHERE id = '789e0123-e89b-12d3-a456-426614174000'
RETURNING *;
```

#### Response (200 OK)
Returns closed sprint object.

### Error Responses

#### Already Closed (400)
```json
{
  "statusCode": 400,
  "message": "Sprint is already closed",
  "error": "Bad Request"
}
```

#### Upcoming Sprint (400)
```json
{
  "statusCode": 400,
  "message": "Upcoming sprints cannot be closed",
  "error": "Bad Request"
}
```

#### Active Cards (400)
```json
{
  "statusCode": 400,
  "message": "Sprint contains active cards. Complete or move all active cards before closing the sprint.",
  "error": "Bad Request"
}
```

---

## Sprint Status Auto-Calculation

### Status Update Triggers
Status is automatically recalculated at:
1. **Sprint fetch** (`findOne`, `findAll`)
2. **Sprint update** (`update`)
3. **Date changes** (when dates are modified)

### Calculation Logic
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 571-592)

```typescript
private calculateSprintStatus(
  startDate: Date,
  endDate: Date,
  isClosed: boolean = false
): SprintStatus {
  // Priority 1: If manually closed, always return CLOSED
  if (isClosed) {
    return SprintStatus.CLOSED;
  }

  // Normalize dates to midnight for fair comparison
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const start = new Date(startDate);
  start.setHours(0, 0, 0, 0);

  const end = new Date(endDate);
  end.setHours(0, 0, 0, 0);

  // Priority 2: Check date ranges
  if (today < start) {
    return SprintStatus.UPCOMING;  // Future sprint
  } else if (today >= start && today <= end) {
    return SprintStatus.ACTIVE;    // Current sprint
  } else {
    return SprintStatus.COMPLETED;  // Past sprint (not formally closed)
  }
}
```

### Status Matrix

| Condition | Status | Can Edit? | Can Delete? | Can Close? | Can Create Snaps? |
|-----------|--------|-----------|-------------|------------|-------------------|
| `today < startDate` | UPCOMING | âœ… Yes | âœ… Yes | âŒ No | âŒ No |
| `today >= startDate && today <= endDate` | ACTIVE | âœ… Yes | âŒ No | âœ… Yes | âœ… Yes |
| `today > endDate && !isClosed` | COMPLETED | âœ… Yes | âŒ No | âœ… Yes | âŒ No |
| `isClosed = true` | CLOSED | âŒ No | âŒ No | âŒ No | âŒ No |

### Batch Status Update
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 597-610)

```typescript
private async updateSprintStatuses(sprints: Sprint[]): Promise<Sprint[]> {
  const updatedSprints: Sprint[] = [];

  for (const sprint of sprints) {
    const newStatus = this.calculateSprintStatus(
      sprint.startDate,
      sprint.endDate,
      sprint.isClosed
    );
    if (sprint.status !== newStatus) {
      sprint.status = newStatus;
      await this.sprintRepository.save(sprint);
    }
    updatedSprints.push(sprint);
  }

  return updatedSprints;
}
```

---

## Daily Standup Slot Configuration

### Single-Slot Configuration (Default)
```json
{
  "dailyStandupCount": 1,
  "slotTimes": null
}
```

- Default configuration
- One standup per day
- No specific time tracking
- All snaps go to slot 1

### Multi-Slot Configuration
```json
{
  "dailyStandupCount": 3,
  "slotTimes": {
    "1": "09:00",
    "2": "12:00",
    "3": "15:00"
  }
}
```

- Multiple standups per day
- Each slot has designated time
- Snaps assigned to specific slot
- Used for distributed teams or multiple meetings

### Slot Assignment Rules
1. **Slot number validation**: `1 <= slotNumber <= dailyStandupCount`
2. **Slot times optional**: Can have multiple slots without specifying times
3. **Time format**: 24-hour format (HH:MM)
4. **Lock granularity**: Locks can be slot-specific or day-level
5. **Snap assignment**: Each snap belongs to exactly one slot

### Slot Configuration UI

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Daily Standup Configuration                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                              â”‚
â”‚  Number of daily standups: [2 â–¼]            â”‚
â”‚                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Slot 1: [09:00] (Morning Standup)    â”‚  â”‚
â”‚  â”‚ Slot 2: [15:00] (Afternoon Check-in) â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                              â”‚
â”‚  [Save Configuration]                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Validations & Business Rules

### Sprint Date Validations
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 455-506)

```typescript
private async validateSprintDates(
  startDate: Date,
  endDate: Date,
  project: Project,
  excludeSprintId: string | null
): Promise<void> {
  const projectStartDate = new Date(project.startDate);
  const projectEndDate = new Date(project.endDate);

  // Normalize dates to midnight for comparison
  const normalizeDate = (date: Date) => {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    return d;
  };

  const normalizedStart = normalizeDate(startDate);
  const normalizedEnd = normalizeDate(endDate);
  const normalizedProjectStart = normalizeDate(projectStartDate);
  const normalizedProjectEnd = normalizeDate(projectEndDate);

  // Rule 1: Sprint start >= Project start
  if (normalizedStart < normalizedProjectStart) {
    throw new BadRequestException('Sprint must lie within project timeline');
  }

  // Rule 2: Sprint end <= Project end
  if (normalizedEnd > normalizedProjectEnd) {
    throw new BadRequestException('Sprint must lie within project timeline');
  }

  // Rule 3: Start date <= End date
  if (normalizedStart > normalizedEnd) {
    throw new BadRequestException('Sprint start date must be before or equal to end date');
  }

  // Rule 4: No overlap with existing sprints
  const existingSprints = await this.sprintRepository.find({
    where: { project: { id: project.id } },
  });

  const hasOverlap = this.checkSprintOverlap(
    normalizedStart,
    normalizedEnd,
    existingSprints,
    excludeSprintId
  );

  if (hasOverlap) {
    throw new BadRequestException('Sprint overlaps with existing sprint');
  }
}
```

### Sprint Name Validation
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.service.ts` (lines 547-566)

```typescript
private async validateUniqueSprintName(
  name: string,
  projectId: string,
  excludeSprintId: string | null
): Promise<void> {
  const queryBuilder = this.sprintRepository
    .createQueryBuilder('sprint')
    .where('sprint.project.id = :projectId', { projectId })
    .andWhere('LOWER(sprint.name) = LOWER(:name)', { name });

  if (excludeSprintId) {
    queryBuilder.andWhere('sprint.id != :excludeSprintId', { excludeSprintId });
  }

  const existingSprint = await queryBuilder.getOne();

  if (existingSprint) {
    throw new BadRequestException('Sprint name must be unique within project');
  }
}
```

### Complete Business Rules Summary

| Rule | Description | Validation Location |
|------|-------------|---------------------|
| **BR-S01** | Sprint dates must be within project timeline | `validateSprintDates()` |
| **BR-S02** | Start date must be <= End date | `validateSprintDates()` |
| **BR-S03** | Sprints cannot overlap (any dates) | `checkSprintOverlap()` |
| **BR-S04** | Sprint name unique within project (case-insensitive) | `validateUniqueSprintName()` |
| **BR-S05** | Cannot create/edit in archived projects | `create()`, `update()` |
| **BR-S06** | Cannot edit closed sprints | `update()` |
| **BR-S07** | Cannot delete sprint with snap history | `remove()` |
| **BR-S08** | Cannot delete sprint with cards | `remove()` (Card module) |
| **BR-S09** | Cannot delete active sprints | `remove()` |
| **BR-S10** | Can only close Active/Completed sprints | `closeSprint()` |
| **BR-S11** | All cards must be completed before closure | `closeSprint()` |
| **BR-S12** | Auto-generation max 100 sprints | `generateSprints()` |
| **BR-S13** | Slot count: 1-5 per day | Validation in DTO |
| **BR-S14** | Status auto-calculated, cannot be manually set | `calculateSprintStatus()` |

---

## Integration Points

### With Projects Module
```typescript
// Sprint belongs to exactly one project
@ManyToOne(() => Project, (project) => project.sprints, { onDelete: 'CASCADE' })
project: Project;
```

**Integration Points:**
- Sprint dates validated against project dates
- Archived projects block sprint operations
- Project deletion cascades to sprints

### With Cards Module
```typescript
// Cards belong to sprint
// Sprint closure requires all cards completed
await this.cardService.areAllCardsCompleted(sprintId);
await this.cardService.closeAllCardsInSprint(sprintId);
```

**Integration Points:**
- Cards assigned to sprint
- Sprint closure validates card status
- Sprint deletion blocked if contains cards

### With Snaps Module
```typescript
// Snaps reference sprint for daily lock validation
@OneToMany(() => StandupUpdate, (standupUpdate) => standupUpdate.sprint)
standupUpdates: StandupUpdate[];
```

**Integration Points:**
- Snaps created within active sprints only
- Sprint status determines snap creation eligibility
- Sprint closure locks all snaps
- Slot configuration used for snap slot assignment

### With Standup Book Module
```typescript
// Standup Book queries active sprint
const sprint = await sprintRepository.findOne({
  where: { project: { id: projectId }, status: SprintStatus.ACTIVE }
});
```

**Integration Points:**
- Standup Book displays active sprint details
- Calendar days calculated from sprint dates
- Daily summaries grouped by sprint

---

## API Reference

### Complete API Endpoints

| Method | Endpoint | Permission | Description |
|--------|----------|------------|-------------|
| POST | `/api/sprints` | CREATE_SPRINT | Create manual sprint |
| POST | `/api/sprints/preview` | VIEW_SPRINT | Preview auto-generated sprints |
| POST | `/api/sprints/generate` | CREATE_SPRINT | Generate sprints automatically |
| GET | `/api/sprints` | VIEW_SPRINT | List all sprints (with filters) |
| GET | `/api/sprints/:id` | VIEW_SPRINT | Get sprint details |
| PATCH | `/api/sprints/:id` | EDIT_SPRINT | Update sprint |
| POST | `/api/sprints/:id/close` | EDIT_SPRINT | Close sprint formally |
| DELETE | `/api/sprints/:id` | DELETE_SPRINT | Delete sprint |

### Controller Reference
**Location**: `F:\StandupSnap\backend\src\sprint\sprint.controller.ts`

```typescript
@Controller('sprints')
@UseGuards(JwtAuthGuard, PermissionsGuard)
export class SprintController {
  @Post()
  @RequirePermissions(Permission.CREATE_SPRINT)
  create(@Body() createSprintDto: CreateSprintDto) { ... }

  @Post('preview')
  @RequirePermissions(Permission.VIEW_SPRINT)
  previewSprints(@Body() previewDto: PreviewSprintsDto) { ... }

  @Post('generate')
  @RequirePermissions(Permission.CREATE_SPRINT)
  generateSprints(@Body() generateSprintsDto: GenerateSprintsDto) { ... }

  @Get()
  @RequirePermissions(Permission.VIEW_SPRINT)
  findAll(@Query('projectId') projectId, @Query('status') status, @Query('search') search) { ... }

  @Get(':id')
  @RequirePermissions(Permission.VIEW_SPRINT)
  findOne(@Param('id') id: string) { ... }

  @Patch(':id')
  @RequirePermissions(Permission.EDIT_SPRINT)
  update(@Param('id') id, @Body() updateSprintDto: UpdateSprintDto) { ... }

  @Post(':id/close')
  @RequirePermissions(Permission.EDIT_SPRINT)
  closeSprint(@Param('id') id: string) { ... }

  @Delete(':id')
  @RequirePermissions(Permission.DELETE_SPRINT)
  remove(@Param('id') id: string) { ... }
}
```

---

## Summary

The Sprints Module provides comprehensive sprint lifecycle management with:
- **Flexible Creation**: Manual or auto-generated sprints
- **Automatic Status Management**: Status calculated based on dates
- **Robust Validation**: No overlaps, date boundaries, name uniqueness
- **Multi-Slot Standups**: Support for multiple daily standup meetings
- **Formal Closure Process**: Ensures data integrity before closing
- **Deep Integration**: Seamlessly works with Projects, Cards, Snaps, and Standup Book

This module forms the backbone of the project's time-boxing and iteration management, enabling teams to organize work into manageable chunks and track progress through daily standups.

---

**Document Version**: 1.0
**Last Updated**: January 2025
**Module Version**: Sprint Module v2.0
**Status**: Complete Implementation
